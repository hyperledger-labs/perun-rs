use super::*;

mod fixed_in_fixed {
    use super::*;

    fn run<T>()
    where
        T: Bytes,
        T: Serialize,
    {
        /*
        ```solidity
            struct DynInFixedarrayInFixedarrayData {
                bytes[3][2] a;
                bytes b;
            }
            function DynInFixedarrayInFixedarray() public pure returns(bytes memory) {
                DynInFixedarrayInFixedarrayData memory d;
                d.a[0][0] = "\xa1\xa2\xa3\xa4";
                d.a[0][1] = "\xb1\xb2\xb3\xb4";
                d.a[0][2] = "\xc1\xc2\xc3\xc4";
                d.a[1][0] = "\xd1\xd2\xd3\xd4";
                d.a[1][1] = "\xe1\xe2\xe3\xe4";
                d.a[1][2] = "\xf1\xf2\xf3\xf4";
                d.b = "\x11\x22\x33\x44\x55";
                return abi.encode(d);
            }
        ```
        */

        #[derive(Serialize, Debug)]
        struct DynInFixedarrayInDynarray<T> {
            a: [[T; 3]; 2],
            #[serde(with = "as_bytes")]
            b: [u8; 5],
        }

        let d = DynInFixedarrayInDynarray {
            a: [
                [T::gen(0xa0), T::gen(0xb0), T::gen(0xc0)],
                [T::gen(0xd0), T::gen(0xe0), T::gen(0xf0)],
            ],
            b: [0x11, 0x22, 0x33, 0x44, 0x55],
        };

        let expected = "
0000000000000000000000000000000000000000000000000000000000000020 // d offset
    0000000000000000000000000000000000000000000000000000000000000040 // d.a offset
    00000000000000000000000000000000000000000000000000000000000002c0 // d.b offset
        0000000000000000000000000000000000000000000000000000000000000040 // d.a[0] offset
        0000000000000000000000000000000000000000000000000000000000000160 // d.a[1] offset
            0000000000000000000000000000000000000000000000000000000000000060 // d.a[0][0] offset
            00000000000000000000000000000000000000000000000000000000000000a0 // d.a[0][1] offset
            00000000000000000000000000000000000000000000000000000000000000e0 // d.a[0][2] offset
                0000000000000000000000000000000000000000000000000000000000000004 // d.a[0][0] length
                a1a2a3a400000000000000000000000000000000000000000000000000000000 // d.a[0][0]

                0000000000000000000000000000000000000000000000000000000000000004 // d.a[0][1] length
                b1b2b3b400000000000000000000000000000000000000000000000000000000 // d.a[0][1]

                0000000000000000000000000000000000000000000000000000000000000004 // d.a[0][2] length
                c1c2c3c400000000000000000000000000000000000000000000000000000000 // d.a[0][2]

            0000000000000000000000000000000000000000000000000000000000000060 // d.a[1][0] offset
            00000000000000000000000000000000000000000000000000000000000000a0 // d.a[1][1] offset
            00000000000000000000000000000000000000000000000000000000000000e0 // d.a[1][2] offset
                0000000000000000000000000000000000000000000000000000000000000004 // d.a[1][0] length
                d1d2d3d400000000000000000000000000000000000000000000000000000000 // d.a[1][0]

                0000000000000000000000000000000000000000000000000000000000000004 // d.a[1][1] length
                e1e2e3e400000000000000000000000000000000000000000000000000000000 // d.a[1][1]

                0000000000000000000000000000000000000000000000000000000000000004 // d.a[1][2] length
                f1f2f3f400000000000000000000000000000000000000000000000000000000 // d.a[1][2]

        0000000000000000000000000000000000000000000000000000000000000005 // d.b length
        1122334455000000000000000000000000000000000000000000000000000000 // d.b
    ";

        serialize_and_compare(&d, expected);
    }

    #[test]
    fn normal_attr() {
        run::<BytesViaNormalAttr>()
    }

    #[test]
    fn tuple_attr() {
        run::<BytesViaTupleAttr>()
    }
}

mod fixed_in_dyn {
    use super::*;

    fn run<T>()
    where
        T: Bytes,
        T: Serialize,
    {
        /*
        ```solidity
            struct DynInFixedarrayInDynarrayData {
                bytes[3][] a;
                bytes b;
            }
            function DynInFixedarrayInDynarray() public pure returns(bytes memory) {
                DynInFixedarrayInDynarrayData memory d;
                d.a = new bytes[3][](2);
                d.a[0][0] = "\xa1\xa2\xa3\xa4";
                d.a[0][1] = "\xb1\xb2\xb3\xb4";
                d.a[0][2] = "\xc1\xc2\xc3\xc4";
                d.a[1][0] = "\xd1\xd2\xd3\xd4";
                d.a[1][1] = "\xe1\xe2\xe3\xe4";
                d.a[1][2] = "\xf1\xf2\xf3\xf4";
                d.b = "\x11\x22\x33\x44\x55";
                return abi.encode(d);
            }
        ```
        */

        #[derive(Serialize, Debug)]
        struct DynInFixedarrayInDynarray<T>
        where
            T: Serialize,
        {
            #[serde(with = "as_dyn_array")]
            a: [[T; 3]; 2],
            #[serde(with = "as_bytes")]
            b: [u8; 5],
        }

        let d = DynInFixedarrayInDynarray {
            a: [
                [T::gen(0xa0), T::gen(0xb0), T::gen(0xc0)],
                [T::gen(0xd0), T::gen(0xe0), T::gen(0xf0)],
            ],
            b: [0x11, 0x22, 0x33, 0x44, 0x55],
        };

        let expected = "
0000000000000000000000000000000000000000000000000000000000000020 // d offset
    0000000000000000000000000000000000000000000000000000000000000040 // d.a offset
    00000000000000000000000000000000000000000000000000000000000002e0 // d.b offset
        0000000000000000000000000000000000000000000000000000000000000002 // d.a length
        0000000000000000000000000000000000000000000000000000000000000040 // d.a[0] offset
        0000000000000000000000000000000000000000000000000000000000000160 // d.a[1] offset
            0000000000000000000000000000000000000000000000000000000000000060 // d.a[0][0] offset
            00000000000000000000000000000000000000000000000000000000000000a0 // d.a[0][1] offset
            00000000000000000000000000000000000000000000000000000000000000e0 // d.a[0][2] offset
                0000000000000000000000000000000000000000000000000000000000000004 // d.a[0][0] length
                a1a2a3a400000000000000000000000000000000000000000000000000000000 // d.a[0][0]

                0000000000000000000000000000000000000000000000000000000000000004 // d.a[0][1] length
                b1b2b3b400000000000000000000000000000000000000000000000000000000 // d.a[0][1]

                0000000000000000000000000000000000000000000000000000000000000004 // d.a[0][2] length
                c1c2c3c400000000000000000000000000000000000000000000000000000000 // d.a[0][2]

            0000000000000000000000000000000000000000000000000000000000000060 // d.a[1][0] offset
            00000000000000000000000000000000000000000000000000000000000000a0 // d.a[1][1] offset
            00000000000000000000000000000000000000000000000000000000000000e0 // d.a[1][2] offset
                0000000000000000000000000000000000000000000000000000000000000004 // d.a[1][0] length
                d1d2d3d400000000000000000000000000000000000000000000000000000000 // d.a[1][0]

                0000000000000000000000000000000000000000000000000000000000000004 // d.a[1][1] length
                e1e2e3e400000000000000000000000000000000000000000000000000000000 // d.a[1][1]

                0000000000000000000000000000000000000000000000000000000000000004 // d.a[1][2] length
                f1f2f3f400000000000000000000000000000000000000000000000000000000 // d.a[1][2]

        0000000000000000000000000000000000000000000000000000000000000005 // d.b length
        1122334455000000000000000000000000000000000000000000000000000000 // d.b
    ";

        serialize_and_compare(&d, expected);
    }

    #[test]
    fn normal_attr() {
        run::<BytesViaNormalAttr>()
    }

    #[test]
    fn tuple_attr() {
        run::<BytesViaTupleAttr>()
    }
}

mod dyn_in_fixed {
    use super::*;

    fn run<T>()
    where
        T: Bytes,
        T: Serialize,
    {
        /*
        ```solidity
            struct DynInDynarrayInFixedarrayData {
                bytes[][2] a;
                bytes b;
            }
            function DynInDynarrayInFixedarray() public pure returns(bytes memory) {
                DynInDynarrayInFixedarrayData memory d;
                d.a[0] = new bytes[](3);
                d.a[0][0] = "\xa1\xa2\xa3\xa4";
                d.a[0][1] = "\xb1\xb2\xb3\xb4";
                d.a[0][2] = "\xc1\xc2\xc3\xc4";
                d.a[1] = new bytes[](3);
                d.a[1][0] = "\xd1\xd2\xd3\xd4";
                d.a[1][1] = "\xe1\xe2\xe3\xe4";
                d.a[1][2] = "\xf1\xf2\xf3\xf4";
                d.b = "\x11\x22\x33\x44\x55";
                return abi.encode(d);
            }
        ```
        */

        #[derive(Serialize, Debug)]
        #[serde(transparent)]
        struct Inner<T>(#[serde(with = "as_dyn_array")] [T; 3])
        where
            T: Serialize;

        #[derive(Serialize, Debug)]
        struct DynInFixedarrayInDynarray<T>
        where
            T: Serialize,
        {
            a: [Inner<T>; 2],
            #[serde(with = "as_bytes")]
            b: [u8; 5],
        }

        let d = DynInFixedarrayInDynarray {
            a: [
                Inner([T::gen(0xa0), T::gen(0xb0), T::gen(0xc0)]),
                Inner([T::gen(0xd0), T::gen(0xe0), T::gen(0xf0)]),
            ],
            b: [0x11, 0x22, 0x33, 0x44, 0x55],
        };

        let expected = "
0000000000000000000000000000000000000000000000000000000000000020 // d offset
    0000000000000000000000000000000000000000000000000000000000000040 // d.a offset
    0000000000000000000000000000000000000000000000000000000000000300 // d.b offset
        0000000000000000000000000000000000000000000000000000000000000040 // d.a[0] offset
        0000000000000000000000000000000000000000000000000000000000000180 // d.a[1] offset
            0000000000000000000000000000000000000000000000000000000000000003 // d.a[0] length
                0000000000000000000000000000000000000000000000000000000000000060 // d.a[0][0] offset
                00000000000000000000000000000000000000000000000000000000000000a0 // d.a[0][1] offset
                00000000000000000000000000000000000000000000000000000000000000e0 // d.a[0][2] offset
                    0000000000000000000000000000000000000000000000000000000000000004 // d.a[0][0] length
                    a1a2a3a400000000000000000000000000000000000000000000000000000000 // d.a[0][0]

                    0000000000000000000000000000000000000000000000000000000000000004 // d.a[0][1] length
                    b1b2b3b400000000000000000000000000000000000000000000000000000000 // d.a[0][1]

                    0000000000000000000000000000000000000000000000000000000000000004 // d.a[0][2] length
                    c1c2c3c400000000000000000000000000000000000000000000000000000000 // d.a[0][2]

                0000000000000000000000000000000000000000000000000000000000000003 // d.a[1] length
                0000000000000000000000000000000000000000000000000000000000000060 // d.a[1][0] offset
                00000000000000000000000000000000000000000000000000000000000000a0 // d.a[1][1] offset
                00000000000000000000000000000000000000000000000000000000000000e0 // d.a[1][2] offset
                    0000000000000000000000000000000000000000000000000000000000000004 // d.a[1][0] length
                    d1d2d3d400000000000000000000000000000000000000000000000000000000 // d.a[1][0]

                    0000000000000000000000000000000000000000000000000000000000000004 // d.a[1][1] length
                    e1e2e3e400000000000000000000000000000000000000000000000000000000 // d.a[1][1]

                    0000000000000000000000000000000000000000000000000000000000000004 // d.a[1][2] length
                    f1f2f3f400000000000000000000000000000000000000000000000000000000 // d.a[1][2]

        0000000000000000000000000000000000000000000000000000000000000005 // d.b length
        1122334455000000000000000000000000000000000000000000000000000000 // d.b
    ";

        serialize_and_compare(&d, expected);
    }

    #[test]
    fn normal_attr() {
        run::<BytesViaNormalAttr>()
    }

    #[test]
    fn tuple_attr() {
        run::<BytesViaTupleAttr>()
    }
}

mod dyn_in_dyn {
    use super::*;

    fn run<T>()
    where
        T: Bytes,
        T: Serialize,
    {
        /*
        ```solidity
            struct DynInDynarrayInDynarrayData {
                bytes[][] a;
                bytes b;
            }
            function DynInDynarrayInDynarray() public pure returns(bytes memory) {
                DynInDynarrayInDynarrayData memory d;
                d.a = new bytes[][](2);
                d.a[0] = new bytes[](3);
                d.a[0][0] = "\xa1\xa2\xa3\xa4";
                d.a[0][1] = "\xb1\xb2\xb3\xb4";
                d.a[0][2] = "\xc1\xc2\xc3\xc4";
                d.a[1] = new bytes[](3);
                d.a[1][0] = "\xd1\xd2\xd3\xd4";
                d.a[1][1] = "\xe1\xe2\xe3\xe4";
                d.a[1][2] = "\xf1\xf2\xf3\xf4";
                d.b = "\x11\x22\x33\x44\x55";
                return abi.encode(d);
            }
        ```
        */

        #[derive(Serialize, Debug)]
        #[serde(transparent)]
        struct Inner<T>(#[serde(with = "as_dyn_array")] [T; 3])
        where
            T: Serialize;

        #[derive(Serialize, Debug)]
        struct DynInFixedarrayInDynarray<T>
        where
            T: Serialize,
        {
            #[serde(with = "as_dyn_array")]
            a: [Inner<T>; 2],
            #[serde(with = "as_bytes")]
            b: [u8; 5],
        }

        let d = DynInFixedarrayInDynarray {
            a: [
                Inner([T::gen(0xa0), T::gen(0xb0), T::gen(0xc0)]),
                Inner([T::gen(0xd0), T::gen(0xe0), T::gen(0xf0)]),
            ],
            b: [0x11, 0x22, 0x33, 0x44, 0x55],
        };

        let expected = "
0000000000000000000000000000000000000000000000000000000000000020 // d offset
    0000000000000000000000000000000000000000000000000000000000000040 // d.a offset
    0000000000000000000000000000000000000000000000000000000000000320 // d.b offset
        0000000000000000000000000000000000000000000000000000000000000002 // d.a length
        0000000000000000000000000000000000000000000000000000000000000040 // d.a[0] offset
        0000000000000000000000000000000000000000000000000000000000000180 // d.a[1] offset
            0000000000000000000000000000000000000000000000000000000000000003 // d.a[0] length
            0000000000000000000000000000000000000000000000000000000000000060 // d.a[0][0] offset
            00000000000000000000000000000000000000000000000000000000000000a0 // d.a[0][1] offset
            00000000000000000000000000000000000000000000000000000000000000e0 // d.a[0][2] offset
                0000000000000000000000000000000000000000000000000000000000000004 // d.a[0][0] length
                a1a2a3a400000000000000000000000000000000000000000000000000000000 // d.a[0][0]

                0000000000000000000000000000000000000000000000000000000000000004 // d.a[0][1] length
                b1b2b3b400000000000000000000000000000000000000000000000000000000 // d.a[0][1]

                0000000000000000000000000000000000000000000000000000000000000004 // d.a[0][2] length
                c1c2c3c400000000000000000000000000000000000000000000000000000000 // d.a[0][2]
            0000000000000000000000000000000000000000000000000000000000000003 // d.a[1] length
            0000000000000000000000000000000000000000000000000000000000000060 // d.a[1][0] offset
            00000000000000000000000000000000000000000000000000000000000000a0 // d.a[1][1] offset
            00000000000000000000000000000000000000000000000000000000000000e0 // d.a[1][2] offset
                0000000000000000000000000000000000000000000000000000000000000004 // d.a[1][0] length
                d1d2d3d400000000000000000000000000000000000000000000000000000000 // d.a[1][0]

                0000000000000000000000000000000000000000000000000000000000000004 // d.a[1][1] length
                e1e2e3e400000000000000000000000000000000000000000000000000000000 // d.a[1][1]

                0000000000000000000000000000000000000000000000000000000000000004 // d.a[1][2] length
                f1f2f3f400000000000000000000000000000000000000000000000000000000 // d.a[1][2]

        0000000000000000000000000000000000000000000000000000000000000005 // d.b length
        1122334455000000000000000000000000000000000000000000000000000000 // d.b
    ";

        serialize_and_compare(&d, expected);
    }

    #[test]
    fn normal_attr() {
        run::<BytesViaNormalAttr>()
    }

    #[test]
    fn tuple_attr() {
        run::<BytesViaTupleAttr>()
    }
}
